## React에서 렌더링을 중요하게 생각해야하는 이유

React는 SPA의 대표 라이브러리로, 여러개의 페이지가 존재해 페이지가 이동되는 것이 아닌 하나의 페이지에서 부분적으로 UI가 업데이트된다. 즉각적으로 UI를 변경함으로써 사용자와의 인터랙션을 높였고, 이런 매끄러운 화면 전환을 보여주어 사용자 경험을 높였는데 장점만 있는 것은 아니다. 하나의 단일 페이지에서 모든 자바스크립트 코드가 돌아가다보니 자바스크립트 용량이 큰 경우 초기 렌더링시 다운로드되는데에 시간이 오래 걸려 사용자가 아무것도 없는 빈화면을 보게될 가능성이 있다는 단점이 있다.

초기 렌더링뿐만 아니라 이후의 리렌더링도 중요하게 생각해야한다. 비효율적인 리렌더링이 계속 발생할 시 React는 계속해서 같은 컴포넌트를 새롭게 호출하게 되는데 이는 어플리케이션 성능이 떨어트려 사용자 경험을 낮출 수 있다. 따라서 SPA의 장점인 즉각적인 UI 변경과 사용자와의 빠른 인터렉션을 위해서는 초기 렌더링뿐만 아니라 이후의 리렌더링에도 계속 신경을 써야하는 것이다. 불필요한 리렌더링을 잡으면 성능을 최적화할 수 있다.

## React의 리렌더링 과정

앞에서 React에서 왜 리렌더링에 대해 중요하게 생각해야하는지를 이야기했다. 그럼 리렌더링은 어떤 과정을 통해 발생하는 걸까? React가 가상 DOM을 가지고 실제 DOM을 업데이트하는 과정을 간단하게 나열해보자면 다음과 같다.

- 리렌더링이 발생하는 과정

  1.  상태(state)나 속성(props)이 변경된다.

  2.  React는 Virtual DOM을 업데이트한다.

  3.  업데이트 이전의 가상돔을 비교하여 변경된 부분을 찾고 실제 DOM 업데이트을 업데이트한다.

[React의 Virtual DOM과 렌더링 방식 이해하기](https://jellieblog.dev/posts/react-virtual-dom-and-rendering)

더 자세한 과정은 이전에 React의 가상돔의 렌더링 방식에 대해 작성한 포스트가 있다!

## 리렌더링 조건 3가지

위에서 리렌더링이 되는 과정을 살펴보았을 때, 그 과정 속에서 리렌더링이 발생하는 중요한 전제 조건을 유추해볼 수 있었다. **바로 상태나 속성이 변경되는 경우**라는 것이다. React에서 리렌더링이 발생하는 조건으로는 3가지가 있다.

1. 상태(state)가 변경되었을 때

   컴포넌트의 상태가 변경되면 해당 컴포넌트와 그 자식 컴포넌트가 리렌더링된다. 이는 `useState`이나 `useReducer`와 같이 상태 관련 훅을 사용하고, 해당 상태가 변경될 때 리렌더링이 발생한다.

   만약 클래스형 컴포넌트라면 `this.setState`를 호출할 때 발생한다.

2. 속성(props) 변경되었을 때

   부모 컴포넌트가 자식 컴포넌트에 전달하는 props가 변경되면, 자식 컴포넌트가 리렌더링된다.

3. 부모 컴포넌트가 리렌더링 되었을 때

   상태나 속성 변경 이외에도 중요하게 생각해야할 조건은 부모 컴포넌트가 리렌더링되면, 자식 컴포넌트들도 모두 리렌더링된다는 것이다. 그래서 컴포넌트를 적절하게 잘 분리하는 것이 중요하다.

이 3가지 이외에도 리렌더링이 일어날 수 있는 한가지 조건이 더 있는데 이 조건은 클래스형 컴포넌트일 때 작동한다.

+추가) 강제 업데이트(forceUpdate) 되었을 때

클래스형 컴포넌트에서 `forceUpdate` 메서드를 호출하면 컴포넌트는 강제로 리렌더링한다. 하지만 잘 사용되지는 않고 반드시 필요할 때만 사용되는 것 같다. 이 포스트에서는 함수형 컴포넌트를 중점적으로 작성할 것이기 때문에 간단하게 조건에 대해 알고만 있으려고 한다.

## 과도한 리렌더링 최적화 기법

이렇게 리렌더링이 발생하는 조건에 대해서 알아보았다. 불필요한 리렌더링이 계속 발생할 때 어플리케이션의 성능이 떨어질 수 있으니 성능 최적화를 위해서는 렌더링을 잘 제어하는 것이 중요한 것 같다. 그럼 이제 어떻게 하면 리렌더링을 최적화할 수 있을까?

### React 내장 기능을 활용한 최적화

React에서 기본적으로 제공하는 내장 기능을 통해 렌더링을 제어할 수 있다. 내장 기능으로 `useEffect`나 `useCallback` 같은 훅이 있는데, 훅을 통해 렌더링을 제어할 수 있다.

여기서 한가지 짚고 넘어가야할 점은 **훅을 통해 렌더링을 최적화**한다는 것은 **함수형 컴포넌트**를 사용한다는 뜻이다. 이 포스트에서는 함수형 컴포넌트를 중점으로 다룬다고 했는데, 함수형 컴포넌트에서 렌더링이란 무엇일까? 함수형 컴포넌트에서 렌더링의 의미는 그 함수를 호출해 반환된 JSX를 통해 화면을 그린다는 것이다. 그렇다면 리렌더링이란 해당 함수를 재호출해서 화면을 그린다는 뜻이 될 수 있다. **함수가 재호출이 된다는 것은 기존에 있었던 변수들은 모두 초기화되고 다시 재연산된다**는 의미이다. 그렇게 때문에 쓸데없는 재연산을 막기 위해 리렌더링을 최적화해야하는 것이다.

함수형 컴포넌트에서 렌더링이 어떤 의미인지 알아보았다. 그럼 이제 React가 제공하는 훅들로 어떻게 렌더링을 최적화할 수 있을까?

#### 1. useEffect

이 부분은 기법이라고 하기에는 조금 애매하지만 그래도 리렌더링과 관련된 부분이고, 또 놓칠 수 있을 것 같은 부분이라서 적어보았다. React는 `useEffect`의 의존성 배열에 있는 요소가 변경될 때마다 리렌더링을 발생시킨다.

```jsx
useEffect(콜백함수, [의존성배열]);
```

따라서 꼭 값이 변경되는 것을 추적해서 UI를 업데이트해야하는 경우에만 의존성 배열에 넣는 것이 좋다. UI와 값의 변화가 별로 상관 없는 경우 의존성 배열에서 제거하면 리렌더링 낭비를 방지할 수 있다. `useEffect`의 의존성 배열에는 꼭 필수 요소만 넣자!

#### 2. useMemo

앞서 함수형 컴포넌트의 경우 리렌더링이 되면 내부 변수가 초기화된다고 이야기했다. `useMemo`는 계산 비용이 높은 연산의 결과값을 메모리에 메모이제이션해서 값이 변경되지 않는다면 해당 연산을 다시 수행하지 않고 이전 값을 사용함으로서 리렌더링을 줄인다.

```jsx
const memoizedValue = useMemo(콜백함수, 의존성배열);
```

하지만 의존성배열에 있는 요소가 변경되는 경우 다시 재연산되니 의존성배열에 적절한 것들만 넣는 것이 좋다. `useMemo`는 **복잡한 계산 로직이나 정렬, 필터링같은 연산**이 자주 발생하는 컴포넌트에서 유용하게 사용할 수 있다. **다른 상태가 업데이트**되어도 `useMemo`를 사용한 값은 연산하지 않고 이전의 값을 재사용하기 때문에 렌더링이 느려지지 않는다.

#### 3. useCallback

`useMemo`는 값 자체를 메모이제이션한다면 `useCallback`은 함수 자체를 메모이제이션해서 하위 컴포넌트가 리렌더링되는 것을 방지해준다.

```jsx
const memoizedCallbackFn = useCallback(콜백함수, 의존성배열);
```

사실 `useCallback`이 함수 자체를 메모이제이션한다는 것은 알고 있었으나 잘 활용은 못했던 것 같다. `useCallback`이 유용하게 사용될 수 있는 상황은 **자식 컴포넌트에 함수를 props로 전달하거나 `useEffect`의 의존성 배열에 함수가 추가되었을 때** 등의 상황에 활용할 수 있다!

`useMemo`와 `useCallback`은 값이나 함수를 메모리에 따로 저장하는 것이므로 여기저기 남용할 경우 오히려 성능이 저하될 수 있다. 따라서 계산 비용이 높은 연산에서만 적절하게 사용하는 것이 좋다.

여기까지 리렌더링을 제어해줄 수 있는 훅들에 대해 살펴보았다. React에서는 기본적인 내장 기능으로 훅 이외에도 **고차 컴포넌트**가 있는데, 고차 컴포넌트인 `React.memo` 또한 렌더링을 제어해줄 수 있다.

#### 4. React.memo

`React.memo`는 `useMemo`와 철자가 비슷하게 생겨서 헷갈릴 수 있는데 `React.memo`는 고차 컴포넌트(HOC)고, `useMemo`는 훅으로 엄연히 기능이 다르다.

`React.memo`는 함수형 컴포넌트 자체를 인자로 받고, 해당 컴포넌트를 메모이제이션해서 props가 변경되지 않는 한 리렌더링을 방지해주는 기법이다.

```jsx
function MyComponent(props) {
  return <div>{props.value}</div>;
}

export default React.memo(MyComponent);
```

보통 나는 이런식으로 작성하고 있다. React.memo는 컴포넌트가 동일한 props를 전달받아 여러번 렌더링되는 경우 이전 렌더링 결과를 재사용해서 성능을 최적화할 수 있다. 부모 컴포넌트가 리렌더링될 때 자식 컴포넌트까지 불필요하게 다시 리렌더링되지 않도록 막을 수 있는 것이다. 아니면 정말 복잡한 렌더링을 요구하는 컴포넌트일 경우에도 React.memo를 사용해 과도한 재계산이나 렌더링을 방지할 수 있다. 하지만 이 부분도 실제 메모리에 저장하는 것이다보니 정말로 필요한 부분만 적용하는 것이 좋겠다.

#### 5. key를 활용한 리스트 렌더링 최적화

이 부분도 잘 놓칠 수 있는 부분이라고 생각해서 작성해보았다. `map` 메서드를 활용하여 리스트같은 여러개의 컴포넌트를 만들어내는 경우 `key` 속성을 작성하게 된다. 작성하지 않으면 에러가 뜨기 때문에 key 속성을 빼먹는 사람은 없을테지만 가끔 고유한 값을 지정해주기 어려운 경우 `map`의 두번째 인자인 `index`를 지정해주는 경우가 있다. 하지만 `key`에 `index` 값을 부여한다면 특히 **동적인 배열**인 경우 엄청난 성능 저하를 불러일으킬 수 있다.

```jsx
// ✅
<ul>
 {items.map((item) => (
   <li key={item.id}>{item.name}</li>
 ))}
</ul>

// ❌
<ul>
 {items.map((item, index) => (
   <li key={index}>{item.name}</li>
 ))}
</ul>
```

[리액트 공식문서](https://ko.react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)에 따르면 `map`을 통해 리스트를 렌더링하는 경우 `index` 사용을 지양하라고 나와있다. 왜냐하면 `index`는 배열에 요소가 추가되거나 삭제되는 경우 다시 모든 요소가 새로운 `index`를 갖게 되기 때문이다. 그러면 이전과 다른 `key` 값을 가지게 되는 것이므로 React는 모든 리스트 요소들이 전부 다시 리렌더링한다. 그런데 이 리스트에 100개의 항목이 있다면? 1000개라면? 엄청난 성능저하가 발생할 것이다. 따라서 React가 이전에 갖고 있던 요소의 `key` 값과 새로 업데이트된 `key` 값이 같다면 다시 리렌더링하지 않을 수 있도록 고유한 `key` 값을 부여해주는 것이 좋다. 특히 동적인 배열인 경우에 `index`가 아닌 고유한 값을 설정해주자!

### React 내장 기능 외의 최적화

#### 1. 적절한 컴포넌트 분리

앞서 리렌더링의 조건 4가지에서 부모 컴포넌트가 리렌더링되면 자식 컴포넌트들 전체가 다시 리렌더링된다고 했다. 자식 컴포넌트는 변경이 될 필요가 없는데 부모의 리렌더링 때문에 같이 다시 리렌더링된다면 굉장히 비효율적일 것이다. 그렇기 때문에 연관된 컴포넌트가 아니라면 독립적으로 분리해주는 것이 좋다. 앞으로 컴포넌트가 적절하게 분리되어 있는지 다시 한번 체크하는 것이 좋을 것 같다.

## 기타 렌더링 최적화 기법

이 부분은 과도한 리렌더링을 제거해주는 기법은 아니지만, 렌더링을 최적화해 사용자 경험을 높여주는 기법인데 리렌더링 최적화와 함께 알면 도움이 될 것 같아서 작성해보았다. 렌더링 최적화 기법에도 React의 내장기능인 훅 3가지와 그외 1가지가 있다.

### React 내장 기능을 이용한 최적화

#### 1. useTransition

`useTransition`은 React 18 버전에서 처음으로 등장한 훅이다. 간단하게 이야기하자면 렌더링에 우선순위를 부여할 수 있는 훅인데, 특정 상태의 우선순위가 낮다면 전환하고 즉각적으로 업데이트되어야 하는 다른 UI 요소들이 중단되지 않고 먼저 반응할 수 있도록 만들어준다. 우선순위가 낮은 상태 업데이트는 `startTransition`을 통해 우선순위가 낮다는 것을 나타낸다.

```jsx
function TabContainer() {
  const [isPending, startTransition] = useTransition();
  const [tab, setTab] = useState('about');

  function selectTab(nextTab) {
    // ✅ startTransition으로 래핑
    startTransition(() => {
      setTab(nextTab);
    });
  }
  // ...
}
```

[이전 포스트(React 18의 새로운 Hook 3가지)](https://jellieblog.dev/posts/react-18-hooks)에서 해당 훅에 작성했던 적이 있어서 더 자세한 내용은 여기를 참고하면 될 것 같다!

#### 2. useDeferredValue

`useDeferredValue` 또한 React 18 버전에서 처음으로 등장한 훅이다. `useDeferredValue`은 **연산 비용이 높은 결과값을 지연**시켜 업데이트를 늦추고 UI에서 응답성을 높이는데 사용된다.

```jsx
import { useState, useDeferredValue } from 'react';

function SearchPage() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  // ...
}
```

예를 들어 사용자가 입력 필드를 작성할 때마다 자동 완성어가 필터링되는 결과를 보여주지 않고 입력을 어느 정도 마친 후 보여줄 때 유용하다.

#### 3. useLayoutEffect

| useEffect                                                                                        | useLayoutEffect                                                                                        |
| ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------ |
| 비동기                                                                                           | 동기                                                                                                   |
| 상태 변화 => 컴포넌트 리렌더링과 돔 업데이트 => **브라우저의 화면 리페인트 => `useEffect` 실행** | 상태 변화 => 컴포넌트 리렌더링과 돔 업데이트 => **`useLayoutEffect` 실행 => 브라우저의 화면 리페인트** |

`useLayoutEffect`는 `useEffect` 비슷하게 생겼지만 리렌더링 최적화 기법이라고 하기엔 애매한 부분이 있다. 불필요한 리렌더링을 방지해준다기보다는 첫 렌더링에 UI의 레이아웃을 최적화하는 것에 더 중점을 둔 훅이기 때문이다. 하지만 렌더링 자체를 최적화해줄수 있는 훅이라고 생각했기 때문에 포함시켜 작성해보았다.

`useEffect`는 브라우저가 모든 화면을 그리고 나서야 바로 실행된다. 만약 `useEffect`에서 상태 변경을 일으키는 코드가 있을 경우 화면 깜박임이 발생할 수 있다. 반대로 `useLayoutEffect`는 DOM 변경 후에 동기적으로 실행되는 훅이다. 브라우저가 화면을 그리기 전에 실행되고, 실행된 결과를 한번의 렌더링 단계에서 해결해 시각적 깜박임을 제거해줄 수 있다. 물론 그렇다고 시각적 깜박임을 해결하기 위해 `useLayoutEffect`을 남용한다면 오히려 렌더링이 늦춰져 시각적 경험을 지연시킬 수 있다. 따라서 적절한 시각적 경험을 보여주는 렌더링을 제공하는지 확인하며 활용하는것이 좋겠다!

한가지 더 기억할 점은 `useLayoutEffect`은 UI를 조정하기 위한 훅으로 API로 데이터를 불러온다거나 서버에서 실행할 코드는 작동하지 않는다는 것이다. 그럴 때는 `useEffect`를 사용해야 한다.

### 디바운싱과 쓰로틀링을 이용한 최적화

#### 1. 디바운싱

디바운싱은 React에서 제공해주는 기능은 아니고 함수가 과도하게 호출되는 것을 방지해주는 프로그래밍 개념이다. React서라면 직접 커스텀 훅으로 만들어서 사용할 수 있다.

> 디바운싱
>
> 정해진 시간 내에서 연이어 호출되는 함수들 중 가장 마지막 함수만 호출한다.

```jsx
// 커스텀 훅: useDebounce.tsx
import { useEffect, useState } from 'react';

const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay || 500);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
};

export default useDebounce;
```

```jsx
// 사용 예시
const debouncedInput = useDebounce(input, 300);
```

#### 2. 쓰로틀링

쓰로틀링 또한 디바운싱과 마찬가지로 함수 호출을 제어해줄 수 있는 프로그래밍 개념이다. 마찬가지로 커스텀 훅으로 만들 수 있다.

> 쓰로틀링
>
> 함수가 한번 호출되면, 일정시간이 지나기 전에 다시 호출되지 않도록 하는 것

```jsx
import { useRef } from 'react';

export function useThrottle(callback, delay) {
  const lastRun = useRef(Date.now());

  return () => {
    const timeElapsed = Date.now() - lastRun.current;

    if (timeElapsed >= delay) {
      callback();
      lastRun.current = Date.now();
    }
  };
}
```

```jsx
// 사용 예시
const handleInput = useThrottle(() => {
  console.log('쓰로틀링 처리된 값');
}, 1000);
```

## 정리

이 포스트에서 React에서 렌더링을 중요하게 생각해야하는 이유와 리렌더링의 조건, 그리고 렌더링 최적화 기법까지 다양하게 알아보고 공부해보았다. 포스트를 작성하면서 다시 한번 `useMemo`나 `useCallback`, `useTransition` 등등 React의 다양한 훅들에 대해 다시 복습해보는 계기가 되었다. 또 내장 기능인 훅을 이용하는 것 이외에도 여러가지로 최적화 기법에 대해 다시 한번 생각해보고, 또 React에서 디바운싱과 쓰로틀링을 어떻게 적용할지 공부해볼 수 있어서 좋았다. 이 포스트를 작성하면서 지금까지 했던 프로젝트에서 렌더링 최적화를 해야하는 부분이 떠올랐는데, 또 앞으로 React 프로젝트를 할 때 항상 렌더링을 최적화하고 있는지 신경써야겠다.

## 참고

[리스트 렌더링](https://ko.react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)
[별코딩: 리액트 디바운스 - Debounce로 서버 비용 아끼는법 | React Custom Hook](https://youtu.be/IVa-FBHMUu4?si=WUPFnzFoBXYVSwYG)
[별코딩: 리액트 쓰로틀링 - 함수도 쿨타임이 필요하다 | Throttle | React Custom Hook](https://youtu.be/X5Ww0Yhr7lM?si=bD35QN2hI_QiNR8Q)
