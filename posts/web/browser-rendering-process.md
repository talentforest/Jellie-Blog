## 브라우저 환경을 잘 알아야 하는 이유

웹 어플리케이션은 다른 프로그래밍 언어와 다르게 **브라우저 환경**에서 실행된다. 따라서 특히 웹을 개발하는 프론트엔드는 브라우저 환경을 고려할 때 더 효율적이고 최적화된 프로그래밍이 가능하다. 프론트엔드를 공부한다면 브라우저는 정말 잘 알고 있어야 하지 않을까 싶다.

## 브라우저의 구성 요소

![img](/public/images/web/browser-rendering-process/browser-compartments.png)

브라우저에는 총 7가지의 구성 요소가 있다.

1. 사용자 인터페이스
2. 브라우저 엔진
3. 렌더링 엔진
4. 자바스크립트 엔진
5. 네트워크
6. UI 백엔드
7. 자료 저장소

위의 그림에서 화살표들을 보면 브라우저의 구성요소들이 상호작용하는지 알 수 있다. 일단 각 구성 요소들에 대해 알아보고, 어떤 상호작용을 하는지 알아보자.

### 사용자 인터페이스

![img](/public/images/web/browser-rendering-process/browser-user-interface.png)

브라우저에서 요청한 웹페이지를 제외하고 **사용자와 상호작용**하는 레이어

- 예시
  - 주소표시줄
  - 이전 / 다음 / 새로고침 등
  - 북마크

### 브라우저 엔진

> 사용자 인터페이스와 렌더링 엔진을 연결하는 레이어. 사용자가 뒤로 가기나 새로고침 같은 버튼을 눌렀을 때 그 명령을 렌더링 엔진에 전달한다.

1. **브라우저 엔진 ↔️ 자료 저장소**

   브라우저 엔진은 네트워크보다 먼저 자료 저장소 레이어에 캐싱된 리소스가 있는지 찾아보고 있다면 해당 리소스를 함께 렌더링 엔진에 전달한다.

2. **브라우저 엔진 ↔️ 렌더링 엔진**

   사용자가 입력한 URI을 렌더링 엔진에 전달한다.

### 자료 저장소

> 쿠키, 로컬 스토리지 등 모든 종류의 자원을 하드 디스크에 저장하는 레이어

1. **자료 저장소 ↔️ 브라우저 엔진**

   브라우저 엔진으로부터 전달받은 URI에 해당하는 리소스가 캐싱되어 있는지 먼저 찾아보고 있다면 브라우저 엔진에 전달한다.

### 렌더링 엔진

> 브라우저 엔진으로부터 URI를 전달받고, 다음 3가지 레이어와 상호작용하면서 요청한 리소스를 화면에 렌더링하는 레이어.

1. **렌더링 엔진 ↔️ 네트워크**

   렌더링 엔진은 URI를 네트워크 레이어에 전달하고 네트워크는 응답하여 URI에 맞는 리소스를 다시 렌더링 엔진에 전달한다.

2. **렌더링 엔진 ↔️ 자바스크립트 엔진**

   네트워크로 전달받은 리소스 중 자바스크립트 코드를 보낸다.

3. **렌더링 엔진 ↔️ UI 백엔드**

   응답으로 받은 콘텐츠 중 HTML, CSS 코드를 파싱해서 렌더 트리를 생성하고 이 렌더 트리를 UI 백엔드에 전달한다. 이 과정은 다음 브라우저의 렌더링 과정에서 더욱 자세히 살펴보자!

렌더링 엔진은 네트워크로부터 응답받은 HTML과 CSS, JS, 이미지나 폰트 파일과 같은 리소스를 화면에 렌더링한다.

- 렌더링 엔진 종류

  - 크롬, 사파리: 웹킷(Webkit) 엔진 사용

  - 파이어폭스: 게코(Gecko) 엔진 사용

### 네트워크

> HTTP 요청을 통해 서버에서 리소스를 요청하는 레이어

1. **네트워크 ↔️ 렌더링 엔진**

   렌더링 엔진으로부터 URI를 전달받고 HTTP 요청을 통해 서버에서 리소스를 요청하고 응답받은 결과를 렌더링 엔진에 다시 전달한다.

### 자바스크립트 엔진

> 웹페이지를 동적으로 변화시키기 위해 필요한 자바스크립트 코드를 해석하고 실행하는 레이어

1. **자바스크립트 엔진 ↔️ 렌더링 엔진**

   렌더링 엔진이 자바스크립트 코드를 전달한다.

- 자바스크립트 엔진 종류

  - 크롬: V8

### UI 백엔드

> 콤보 박스나 드랍 다운, 창 같은 기본적인 UI 요소를 그리고 상태와 이벤트를 관리한다.

1. **UI 백엔드 ↔️ 렌더링 엔진**

   렌더링 엔진이 생성한 렌더 트리를 전달받아 관리한다. 렌더링 엔진은 HTML과 CSS를 파싱하여 화면에 표시하고 UI 백엔드는 화면에 표시된 요소들을 관리하고 사용자 인터페이스를 제어한다.

2. **UI 백엔드 ↔️ 사용자 인터페이스**

   브라우저의 UI(사용자 인터페이스)인 창, 버튼, 메뉴 같은 UI 요소를 생성하고 관리한다. 또한 사용자 입력 및 이벤트에 대한 처리를 담당하고 브라우저의 창을 관리하고 조작한다.

   예를 들어 어떤 버튼이 있을 때 버튼이 활성화되어 있는지에 대한 상태, 클릭시 어떤 이벤트에 대한 처리를 담당한다.

&nbsp;

여기까지 브라우저의 구성 요소와 각 구성 요소들이 어떻게 상호작용하는지를 알아보았다. 그러면 이제 브라우저가 어떤 과정을 통해 렌더링되는 것인지를 알아보자.

## 브라우저의 렌더링 과정

사용자는 주소를 입력하면 브라우저는 URI에 맞는 리소스를 응답받는다. 그렇다면 그 리소스는 어떤 과정을 통해 화면에 보이는 걸까?

![img](/public/images/web/browser-rendering-process/rendering-process.png)

> 1. HTML, CSS 파서
> 2. 각각 DOM, CSSOM 생성 후 결합
> 3. 렌더 트리
> 4. 레이아웃
> 5. 페인트
> 6. 레이어 합성

1.  **HTML과 CSS 파싱 후 각각 DOM, CSSOM 생성**

    구성 요소의 렌더링 엔진은 응답받은 리소스 중 HTML과 CSS를 파싱하기 시작한다.

    **✅ DOM** (Document Object Model)의 생성 과정

    1.  렌더링 엔진이 HTML 파싱을 시작해 문법적 의미를 갖는 최소 단위인 토큰으로 분해한다.
    2.  각 토큰(예약어, 연산자, 상수, 식별자)들을 객체로 변환하여 노드를 생성한다.
    3.  HTML 요소는 부모 요소와 자식 요소 간 계층적 구조를 갖고 있고, 이런 관계를 바탕으로 모든 노드들을 트리 자료구조로 구성한다.

        - 이 트리 자료 구조가 바로 DOM이다.

    **✅ CSSOM** (CSS Object Model)의 생성 과정

    1. 렌더링 엔진은 DOM을 생성하다가 `<link>`나 `<style>` 태그를 만나면 DOM 생성을 일시중단하고 서버에 CSS 파일을 요청한다.
    2. CSS는 HTML과 동일한 파싱 과정을 거친다.
    3. CSS는 부모 요소에 적용한 프로퍼티를 자식 요소에 상속하는데 이 상속 관계를 반영하여 자료구조가 생성된다.

2.  **자바스크립트 파싱**

    HTML 파일 내부에 `<script>` 태그를 만나면 DOM 생성을 일시 중단하고 서버에서 자바스크립트 파일을 다운받는다. 이후 다운받은 자바스크립트 파일을 파싱하기 시작하기 위해 렌더링 엔진이 자바스크립트 엔진에게 제어권을 넘긴다.

    자바스크립트를 파싱하고 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 DOM 생성을 재개한다.

    - 브라우저에서 자바스크립트 파일 용량이 크다면 자바스크립트의 파싱을 끝낼때까지 DOM을 생성하지 못하고 화면을 렌더링하지 못한다는 뜻이 된다. 이에 대한 불편함을 해결하기 위해 `defer`과 `async` 속성이 추가되었다.

      - `async`
        이 속성을 사용하면 브라우저는 스크립트를 비동기적으로 로드한다. 스크립트를 로드하는 동안 렌더 트리도 같이 생성한다. 다른 리소스가 로드되는 동안에도 스크립트가 실행되어 페이지 로드 속도가 향상될 수 있다.

      - `defer`
        이 속성을 사용하면 스크립트 파싱을 지연시켜 렌더 트리를 먼저 생성 완료하고 스크립트 파싱을 시작한다는 의미이다.

    만약 자바스크립트 파일을 통해 DOM나 CSSOM에 변경 사항이 발생한다면 변경된 DOM이나 CSSOM을 렌더 트리에 다시 결합한다.

    - 렌더링 엔진에서 렌더 트리가 생성되었다면 브라우저 화면에 그릴 준비가 완료된 것이다.

3.  **렌더 트리 생성**

    HTML을 통해 생성된 DOM, CSS을 통해 생성된 CSSOM을 결합해 렌더 트리를 생성한다.

    - 렌더 트리는 렌더링을 위한 트리 구조이다. 렌더 트리는 브라우저 화면에 렌더링되는 노드들만으로 구성된다.

      - 따라서 **화면에 렌더링되지 않는 노드**(meta 태그, script 태그), **CSS의 display:none 속성**이 적용된 노드는 포함되지 않는다.

4.  **레이아웃**

    렌더 트리의 생성이 끝났다면 이제 렌더 트리의 노드들을 화면의 정확한 위치에 배치하고 표시하는 과정을 시작한다. 이 과정을 레이아웃이라고 하며, 각 노드의 위치와 크기, 너비, 높이 등을 계산하고 화면에 배치한다. 계산하는 단계이기 때문에 CPU를 활용한다. 그리고 초기 배치 이후 요소의 위치나 크기가 변경될 때 레이아웃이 다시 일어나는 것을 리플로우라고 한다.

5.  **페인팅**

    - 레이아웃을 통해 계산된 각 노드들을 화면에 그려주는 과정을 시작한다. 각 노드를 실제 픽셀로 나타내며 이 과정을 통해 화면에 실제 UI가 나타나게 된다. 실제 화면에 색을 입히는 등 그리는 단계이기 때문에 GPU를 사용한다.

> 브라우저에서 이 모든 출력되는 단계를 **Critical Rendering Path** 라고 한다

6. **레이어 합성**

   한 화면에 모든 것을 그리지 않고 여러 레이아웃에 그려서 이것을 합치는 것이다. 예를 들어 스타일 속성에 z-index 속성을 생각해보면 이해가 될 것이다. z-index 값에 따라 맨 위에 놓을수도, 아래에 놓을 수도 있었다. 레이어를 여러개 만들어 합성하는 이유는 페인팅 과정이 렌더링 엔진에서 꽤 시간이 걸리는 과정이기 때문이다. 따라서 그림자나 그라디언트 같은 효과는 다른 레이어에 두어 만약 이 부분에 대한 변경 사항이 없다면 다시 그리지 않아도 된다. 여러 장을 만들어 놓고 변경된 레이아웃 레이어만 업데이트하면 되기 때문에 더 효율적인 렌더링이 가능하다.

## 렌더링 최적화하기 Critical Rendering Path 줄이기

![img](/public/images/web/browser-rendering-process/rendering-reprocess.png)

- 레이아웃부터 UI가 업데이트될 때

  초기 레이아웃 과정 이후, 사용자와의 상호작용으로 UI가 레이아웃 단계를 반복하는 것을 리플로우(Reflow)라고 한다. 주로 요소의 위치나 크기가 변경될 때, 아니면 브라우저 창의 크기가 바뀔 때 발생한다.

  레이아웃 과정은 다시 수치를 계산하고 페인팅을 하고 레이어를 합성하기 때문에 이 부분이 가장 오래 걸린다.

  - 레이아웃 최적화

    1. 불필요한 레이아웃을 줄인다.

- 페인팅부터 UI가 업데이트될 때

  초기 페인팅 과정 이후, 사용자와의 상호작용으로 UI가 페인팅 단계를 반복하는 것을 리페인트(Repaint)라고 한다.

  - 페인트 최적화

    1. 불필요한 페인트 속성을 사용하지 않는다.

- 레이어의 합성만 다시 발생하는 경우

  - 레이아웃과 페인팅 과정을 거치지 않기 때문에 성능상으로 가장 큰 이점을 가진다.

  - 합성 단계의 스타일인 `transform`을 적극적으로 활용하면 애니메이션 성능에 좋다.

  - 또다른 합성 단계의 스타일인 `opacity`속성은 `display: none` 속성을 사용하는 것보다 성능 개선에 도움이 될 수 있다.

레이아웃의 재계산과 재페인팅은 성능에 악형향을 주는 작업임을 기억해야 한다. 리렌더링이 빈번하게 발생하지 않도록 주의할 필요가 있다.

&nbsp;

&nbsp;

참고

- [MDN:웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work)
- [MDN: 중요 렌더링 경로](https://developer.mozilla.org/ko/docs/Web/Performance/Critical_rendering_path)
- [Naver D2: 브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)
- [개인 블로그:](https://nykim.work/118)
